# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
# -*- coding: utf-8 -*-
import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import requests
from datetime import datetime, timedelta

st.set_page_config(page_title="å°ç£ ETF æ™ºæ…§æ’åº", layout="wide")
st.title("ğŸ“Š å°ç£ç†±é–€ ETF + å€‹äººåŒ–é¢¨éšªæ’åº (æ°¸çºŒæ›´æ–°)")

CACHE_TTL = 300
TOP_N = 5
TRADING_DAYS = 252

# -------------------------------
# 1ï¸âƒ£ çˆ¬å–ç†±é–€ ETFï¼ˆYahoo å¥‡æ‘© ETF æ’è¡Œæ¦œï¼‰
# -------------------------------
@st.cache_data(ttl=CACHE_TTL)
def fetch_hot_etf():
    try:
        url = "https://tw.stock.yahoo.com/etf/market-movers"
        tables = pd.read_html(url)
        df = pd.concat(tables, ignore_index=True)
        # æŠ“ä»£ç¢¼æ¬„ä½ï¼Œæ ¼å¼åŒ–æˆ yfinance å¯ç”¨çš„ ticker
        df["ä»£ç¢¼"] = df["ä»£ç¢¼"].astype(str) + ".TW"
        return df["ä»£ç¢¼"].tolist()
    except Exception:
        # fallback: å›ºå®š ETF åˆ—è¡¨
        return ["0050.TW","0056.TW","006208.TW","00713.TW","00878.TW","00692.TW","00900.TW","00695B.TW","00794B.TW","00772B.TW"]

# -------------------------------
# 2ï¸âƒ£ ETF å‹æ…‹ mapping
# -------------------------------
ETF_TYPE_MAPPING = {
    "0050.TW": "è‚¡ç¥¨å‹",
    "0056.TW": "é«˜è‚¡æ¯å‹",
    "006208.TW": "è‚¡ç¥¨å‹",
    "00713.TW": "é«˜è‚¡æ¯å‹",
    "00878.TW": "é«˜è‚¡æ¯å‹",
    "00692.TW": "è‚¡ç¥¨å‹",
    "00900.TW": "é«˜è‚¡æ¯å‹",
    "00695B.TW": "å‚µåˆ¸å‹",
    "00794B.TW": "å‚µåˆ¸å‹",
    "00772B.TW": "å‚µåˆ¸å‹",
    "00757.TW": "è‚¡ç¥¨å‹",
}

# -------------------------------
# 3ï¸âƒ£ æŠ“ ETF è©³ç´°è³‡è¨Šï¼ˆ100% é˜²å‘†ï¼‰
# -------------------------------
@st.cache_data(ttl=CACHE_TTL)
def fetch_etf_info(code):
    try:
        ticker = yf.Ticker(code)
        history = ticker.history(period="1y", actions=True)
        if history.empty:
            return {
                "ä»£ç¢¼": code,
                "åç¨±": code,
                "å‹æ…‹": ETF_TYPE_MAPPING.get(code,"æœªçŸ¥å‹æ…‹"),
                "å³æ™‚åƒ¹": 0.0,
                "å¹´åŒ–é…æ¯ç‡ (%)": 0.0,
                "æœ€æ–°é™¤æ¯é‡‘é¡": 0.0,
                "æœ€æ–°é™¤æ¯æ—¥": "N/A",
                "éå»ä¸€å¹´ç¸½å ±é…¬ç‡ (%)": 0.0
            }
        price_now = history["Close"].iloc[-1]

        # è‚¡æ¯
        if "Dividends" in history.columns:
            dividends = history["Dividends"].fillna(0)
            total_div = dividends.sum()
            div_ann = total_div * (TRADING_DAYS / len(history))
            recent_div = dividends[dividends > 0]
            if not recent_div.empty:
                latest_div_value = recent_div.iloc[-1]
                latest_div_date = recent_div.index[-1].strftime("%Y-%m-%d")
            else:
                latest_div_value = 0.0
                latest_div_date = "N/A"
        else:
            total_div = 0.0
            div_ann = 0.0
            latest_div_value = 0.0
            latest_div_date = "N/A"

        # éå»ä¸€å¹´ç¸½å ±é…¬ç‡
        price_1y_ago = history["Close"].iloc[0]
        total_return = (price_now + total_div)/price_1y_ago -1
        total_return = round(total_return*100,2)

        return {
            "ä»£ç¢¼": code,
            "åç¨±": code,
            "å‹æ…‹": ETF_TYPE_MAPPING.get(code,"æœªçŸ¥å‹æ…‹"),
            "å³æ™‚åƒ¹": round(price_now,2),
            "å¹´åŒ–é…æ¯ç‡ (%)": round(div_ann/price_1y_ago*100,2),
            "æœ€æ–°é™¤æ¯é‡‘é¡": round(latest_div_value,2),
            "æœ€æ–°é™¤æ¯æ—¥": latest_div_date,
            "éå»ä¸€å¹´ç¸½å ±é…¬ç‡ (%)": total_return
        }
    except Exception:
        return {
            "ä»£ç¢¼": code,
            "åç¨±": code,
            "å‹æ…‹": ETF_TYPE_MAPPING.get(code,"æœªçŸ¥å‹æ…‹"),
            "å³æ™‚åƒ¹": 0.0,
            "å¹´åŒ–é…æ¯ç‡ (%)": 0.0,
            "æœ€æ–°é™¤æ¯é‡‘é¡": 0.0,
            "æœ€æ–°é™¤æ¯æ—¥": "N/A",
            "éå»ä¸€å¹´ç¸½å ±é…¬ç‡ (%)": 0.0
        }

# -------------------------------
# 4ï¸âƒ£ Î¸-model
# -------------------------------
def calculate_theta(age,horizon,loss_tol,market_react,expected_return,expected_dividend):
    theta = (
        -0.03*(age-40)
        +0.04*horizon
        +0.05*(loss_tol-15)
        +{"ç«‹å³è³£å‡º":-1,"æŒæœ‰è§€æœ›":0,"é€¢ä½åŠ ç¢¼":1.2}[market_react]
        +0.03*expected_return
        +0.02*expected_dividend
    )
    return round(theta,2)

# -------------------------------
# 5ï¸âƒ£ ETF é¢¨éšªæŒ‡æ•¸
# -------------------------------
def compute_etf_risk_index(row):
    type_risk = {"å‚µåˆ¸å‹":0.2,"é«˜è‚¡æ¯å‹":0.5,"è‚¡ç¥¨å‹":0.8}.get(row["å‹æ…‹"],0.6)
    score = 0.4*type_risk + 0.3*(100-row["éå»ä¸€å¹´ç¸½å ±é…¬ç‡ (%)"])*0.01 + 0.3*(100-row["å¹´åŒ–é…æ¯ç‡ (%)"])*0.01
    return round(score,3)

# -------------------------------
# ä½¿ç”¨è€…è¼¸å…¥
# -------------------------------
cols = st.columns(6)
age = cols[0].slider("ğŸ‘¤ å¹´é½¡",20,80,35)
horizon = cols[1].slider("â³ æŠ•è³‡å¹´é™",1,40,10)
loss_tol = cols[2].slider("ğŸ’¥ æœ€å¤§å¯æ¥å—æå¤± (%)",0,50,15)
expected_return = cols[3].slider("ğŸ¯ é æœŸå ±é…¬ (%)",0,50,10)
expected_dividend = cols[4].slider("ğŸ’° æœŸæœ›é…æ¯ (%)",0,50,3)
market_react = cols[5].radio("ğŸ“‰ å¸‚å ´ä¸‹è·Œ 20%", ["ç«‹å³è³£å‡º","æŒæœ‰è§€æœ›","é€¢ä½åŠ ç¢¼"])

# -------------------------------
# æŠ“ç†±é–€ ETF
# -------------------------------
if st.button("ğŸ“¡ æŠ“ç†±é–€ ETF æœ€æ–°è³‡è¨Š"):
    etf_codes = fetch_hot_etf()
    df_list = [fetch_etf_info(code) for code in etf_codes]
    df = pd.DataFrame(df_list)
    st.subheader("ğŸ“ˆ æœ€æ–°ç†±é–€ ETF è³‡è¨Š")
    st.dataframe(df, use_container_width=True)

# -------------------------------
# è¨ˆç®—å€‹äººåŒ–æ¨è–¦
# -------------------------------
if st.button("ğŸš€ è¨ˆç®—å€‹äººåŒ–æ¨è–¦"):
    etf_codes = fetch_hot_etf()
    df_list = [fetch_etf_info(code) for code in etf_codes]
    df = pd.DataFrame(df_list)
    df["ETFé¢¨éšªæŒ‡æ•¸"] = df.apply(compute_etf_risk_index,axis=1)
    theta = calculate_theta(age,horizon,loss_tol,market_react,expected_return,expected_dividend)
    if theta < -0.5:
        level = "ğŸŸ¢ä¿å®ˆå‹"
    elif theta <0.8:
        level = "ğŸŸ¡å¹³è¡¡å‹"
    else:
        level = "ğŸ”´ç©æ¥µå‹"
    df["èˆ‡æŠ•è³‡äººè·é›¢"] = (df["ETFé¢¨éšªæŒ‡æ•¸"]-theta).abs()
    st.subheader(f"ğŸ“Š æŠ•è³‡äºº Î¸ å€¼ï¼š{theta}  | é¢¨éšªç­‰ç´šï¼š{level}")
    st.dataframe(df.sort_values("èˆ‡æŠ•è³‡äººè·é›¢").head(TOP_N), use_container_width=True)

st.info("ğŸ“Œ è³‡æ–™ä¾†æºï¼šYahoo Financeï½œåƒ…ä¾›åƒè€ƒï¼ŒæŠ•è³‡éœ€è‡ªè² é¢¨éšª")
