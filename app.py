# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
# -*- coding: utf-8 -*-
import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
from datetime import datetime, timedelta

# ===============================
# 0ï¸âƒ£ ç³»çµ±è¨­å®š
# ===============================
CACHE_TTL = 300
TOP_N = 5
TRADING_DAYS = 252

# ===============================
# 1ï¸âƒ£ ETF å‹æ…‹ mapping
# ===============================
ETF_TYPE_MAPPING = {
    "0050.TW": "è‚¡ç¥¨å‹",
    "0056.TW": "é«˜è‚¡æ¯å‹",
    "006208.TW": "è‚¡ç¥¨å‹",
    "00713.TW": "é«˜è‚¡æ¯å‹",
    "00878.TW": "é«˜è‚¡æ¯å‹",
    "00692.TW": "è‚¡ç¥¨å‹",
    "00900.TW": "é«˜è‚¡æ¯å‹",
    "00695B.TW": "å‚µåˆ¸å‹",
    "00794B.TW": "å‚µåˆ¸å‹",
    "00772B.TW": "å‚µåˆ¸å‹",
    "00757.TW": "è‚¡ç¥¨å‹",
}
ETF_CODES = list(ETF_TYPE_MAPPING.keys())

# ===============================
# 2ï¸âƒ£ æŠ“ç†±é–€ ETFï¼ˆæˆäº¤é‡æ’åº fallbackï¼‰
# ===============================
@st.cache_data(ttl=CACHE_TTL)
def fetch_top_etf_by_volume(etf_list, top_n=10):
    data = []
    for code in etf_list:
        try:
            df = yf.download(code, period="5d", progress=False)
            if df.empty or "Volume" not in df.columns:
                continue
            avg_vol = df["Volume"].mean()
            if pd.isna(avg_vol) or avg_vol == 0:
                continue
            data.append((code, avg_vol))
        except Exception:
            continue
    if not data:
        return etf_list[:top_n]
    df_vol = pd.DataFrame(data, columns=["ä»£ç¢¼", "å¹³å‡æˆäº¤é‡"])
    df_vol = df_vol.dropna(subset=["å¹³å‡æˆäº¤é‡"])
    df_vol = df_vol.sort_values("å¹³å‡æˆäº¤é‡", ascending=False)
    return df_vol["ä»£ç¢¼"].tolist()[:top_n]

# ===============================
# 3ï¸âƒ£ æŠ“å– ETF è©³ç´°è³‡è¨Šï¼ˆ100% é˜²å‘†ï¼Œç”¨ history()ï¼‰
# ===============================
@st.cache_data(ttl=CACHE_TTL)
def fetch_etf_info(code):
    try:
        ticker = yf.Ticker(code)
        # éå»ä¸€å¹´è³‡æ–™
        history = ticker.history(period="1y", actions=True)
        if history.empty:
            # fallback
            return {
                "ä»£ç¢¼": code,
                "åç¨±": code,
                "å‹æ…‹": ETF_TYPE_MAPPING.get(code, "æœªçŸ¥å‹æ…‹"),
                "å³æ™‚åƒ¹": 0.0,
                "å¹´åŒ–é…æ¯ç‡ (%)": 0.0,
                "æœ€æ–°é™¤æ¯é‡‘é¡": 0.0,
                "æœ€æ–°é™¤æ¯æ—¥": "N/A",
                "éå»ä¸€å¹´ç¸½å ±é…¬ç‡ (%)": 0.0
            }

        # å³æ™‚åƒ¹
        price_now = history["Close"].iloc[-1]

        # è‚¡æ¯è³‡æ–™
        if "Dividends" in history.columns:
            dividends = history["Dividends"]
            total_div = dividends.sum()
            div_ann = total_div * (TRADING_DAYS / len(history))  # å¹´åŒ–
            # æœ€æ–°é™¤æ¯
            recent_div = dividends[dividends>0]
            if not recent_div.empty:
                latest_div_value = recent_div.iloc[-1]
                latest_div_date = recent_div.index[-1].strftime("%Y-%m-%d")
            else:
                latest_div_value = 0.0
                latest_div_date = "N/A"
        else:
            total_div = 0.0
            div_ann = 0.0
            latest_div_value = 0.0
            latest_div_date = "N/A"

        # éå»ä¸€å¹´ç¸½å ±é…¬ç‡ = (æœ€å¾Œæ”¶ç›¤ + ç´¯ç©è‚¡æ¯) / ä¸€å¹´å‰æ”¶ç›¤ - 1
        price_1y_ago = history["Close"].iloc[0]
        total_return = (price_now + total_div) / price_1y_ago - 1
        total_return = round(total_return * 100, 2)

        return {
            "ä»£ç¢¼": code,
            "åç¨±": code,
            "å‹æ…‹": ETF_TYPE_MAPPING.get(code, "æœªçŸ¥å‹æ…‹"),
            "å³æ™‚åƒ¹": round(price_now, 2),
            "å¹´åŒ–é…æ¯ç‡ (%)": round(div_ann / price_1y_ago * 100, 2),
            "æœ€æ–°é™¤æ¯é‡‘é¡": round(latest_div_value, 2),
            "æœ€æ–°é™¤æ¯æ—¥": latest_div_date,
            "éå»ä¸€å¹´ç¸½å ±é…¬ç‡ (%)": total_return
        }
    except Exception:
        # å®Œå…¨é˜²å‘†
        return {
            "ä»£ç¢¼": code,
            "åç¨±": code,
            "å‹æ…‹": ETF_TYPE_MAPPING.get(code, "æœªçŸ¥å‹æ…‹"),
            "å³æ™‚åƒ¹": 0.0,
            "å¹´åŒ–é…æ¯ç‡ (%)": 0.0,
            "æœ€æ–°é™¤æ¯é‡‘é¡": 0.0,
            "æœ€æ–°é™¤æ¯æ—¥": "N/A",
            "éå»ä¸€å¹´ç¸½å ±é…¬ç‡ (%)": 0.0
        }

# ===============================
# 4ï¸âƒ£ Î¸-model
# ===============================
def calculate_theta(age, horizon, loss_tol, market_react, expected_return, expected_dividend):
    theta = (
        -0.03 * (age - 40) +
        0.04 * horizon +
        0.05 * (loss_tol - 15) +
        {"ç«‹å³è³£å‡º": -1, "æŒæœ‰è§€æœ›": 0, "é€¢ä½åŠ ç¢¼": 1.2}[market_react] +
        0.03 * expected_return +
        0.02 * expected_dividend
    )
    return round(theta, 2)

# ===============================
# 5ï¸âƒ£ ETF é¢¨éšªæŒ‡æ•¸
# ===============================
def compute_etf_risk_index(row):
    type_risk = {"å‚µåˆ¸å‹": 0.2, "é«˜è‚¡æ¯å‹": 0.5, "è‚¡ç¥¨å‹": 0.8}.get(row["å‹æ…‹"], 0.6)
    score = 0.4 * type_risk + 0.3 * (100 - row["éå»ä¸€å¹´ç¸½å ±é…¬ç‡ (%)"]) * 0.01 + 0.3 * (100 - row["å¹´åŒ–é…æ¯ç‡ (%)"]) * 0.01
    return round(score, 3)

# ===============================
# 6ï¸âƒ£ Streamlit UI
# ===============================
st.set_page_config(page_title="å°ç£ ETF æ™ºæ…§æ’åº", layout="wide")
st.title("ğŸ“Š å°ç£ ETF å‹•æ…‹è³‡è¨Š + å€‹äººåŒ–é¢¨éšªæ’åº (100% é˜²å‘†)")

# ä½¿ç”¨è€…è¼¸å…¥
cols = st.columns(6)
age = cols[0].slider("ğŸ‘¤ å¹´é½¡", 20, 80, 35)
horizon = cols[1].slider("â³ æŠ•è³‡å¹´é™", 1, 40, 10)
loss_tol = cols[2].slider("ğŸ’¥ æœ€å¤§å¯æ¥å—æå¤± (%)", 0, 50, 15)
expected_return = cols[3].slider("ğŸ¯ é æœŸå ±é…¬ (%)", 0, 50, 10)
expected_dividend = cols[4].slider("ğŸ’° æœŸæœ›é…æ¯ (%)", 0, 50, 3)
market_react = cols[5].radio("ğŸ“‰ å¸‚å ´ä¸‹è·Œ 20%", ["ç«‹å³è³£å‡º","æŒæœ‰è§€æœ›","é€¢ä½åŠ ç¢¼"])

# -------------------------------
# æŠ“ç†±é–€ ETF
# -------------------------------
if st.button("ğŸ“¡ æŠ“ç†±é–€ ETF æœ€æ–°è³‡è¨Š"):
    top_etfs = fetch_top_etf_by_volume(ETF_CODES, top_n=10)
    df_list = [fetch_etf_info(code) for code in top_etfs]
    df = pd.DataFrame(df_list)
    st.subheader("ğŸ“ˆ æœ€æ–°ç†±é–€ ETF è³‡è¨Š")
    st.dataframe(df, use_container_width=True)

# -------------------------------
# è¨ˆç®—å€‹äººåŒ–æ¨è–¦
# -------------------------------
if st.button("ğŸš€ è¨ˆç®—å€‹äººåŒ–æ¨è–¦"):
    top_etfs = fetch_top_etf_by_volume(ETF_CODES, top_n=10)
    df_list = [fetch_etf_info(code) for code in top_etfs]
    df = pd.DataFrame(df_list)
    df["ETFé¢¨éšªæŒ‡æ•¸"] = df.apply(compute_etf_risk_index, axis=1)
    theta = calculate_theta(age, horizon, loss_tol, market_react, expected_return, expected_dividend)
    df["èˆ‡æŠ•è³‡äººè·é›¢"] = (df["ETFé¢¨éšªæŒ‡æ•¸"] - theta).abs()
    st.subheader(f"ğŸ“Š æŠ•è³‡äºº Î¸ å€¼ï¼š{theta}")
    st.dataframe(df.sort_values("èˆ‡æŠ•è³‡äººè·é›¢").head(TOP_N), use_container_width=True)

st.info("ğŸ“Œ è³‡æ–™ä¾†æºï¼šYahoo Financeï½œåƒ…ä¾›åƒè€ƒï¼ŒæŠ•è³‡éœ€è‡ªè² é¢¨éšª")
