# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
# -*- coding: utf-8 -*-
import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf

# ===============================
# 0ï¸âƒ£ ç³»çµ±è¨­å®š
# ===============================
CACHE_TTL = 300
TOP_N = 5
TRADING_DAYS = 252

# å¸¸ç”¨å°è‚¡ ETF åå–®ï¼ˆå¯æ“´å……ï¼‰
ETF_CODES = [
    "0050.TW", "0056.TW", "006208.TW", "00713.TW",
    "00878.TW", "00692.TW", "00900.TW", "00695B.TW",
    "00794B.TW", "00772B.TW", "00757.TW"
]

# ===============================
# 1ï¸âƒ£ æŠ“ç†±é–€ ETFï¼ˆéå»æˆäº¤é‡æ’åºï¼‰
# ===============================
@st.cache_data(ttl=CACHE_TTL)
def fetch_top_etf_by_volume(etf_list, top_n=5):
    data = []
    for code in etf_list:
        try:
            df = yf.download(code, period="5d", progress=False)
            if df.empty:
                continue
            avg_vol = df["Volume"].mean()
            data.append((code, avg_vol))
        except Exception:
            continue
    if not data:
        return []
    df_vol = pd.DataFrame(data, columns=["ä»£ç¢¼", "å¹³å‡æˆäº¤é‡"])
    df_vol = df_vol.sort_values("å¹³å‡æˆäº¤é‡", ascending=False)
    return df_vol["ä»£ç¢¼"].tolist()[:top_n]

# ===============================
# 2ï¸âƒ£ æŠ“ Yahoo Finance æ­·å²åƒ¹æ ¼
# ===============================
@st.cache_data(ttl=CACHE_TTL)
def fetch_price_history(code: str) -> pd.Series:
    try:
        data = yf.download(code, period="3y", progress=False)
        if data.empty:
            return pd.Series(dtype=float)
        if "Adj Close" in data.columns:
            return data["Adj Close"].dropna()
        return pd.Series(dtype=float)
    except Exception:
        return pd.Series(dtype=float)

# ===============================
# 3ï¸âƒ£ è¨ˆç®—é¢¨éšªæŒ‡æ¨™
# ===============================
def calculate_risk_metrics(price: pd.Series):
    if price.empty or len(price) < 2:
        return 0.0, 0.0
    returns = price.pct_change().dropna()
    volatility = returns.std() * np.sqrt(TRADING_DAYS)
    drawdown = (price / price.cummax() - 1).min()
    return round(volatility,4), round(abs(drawdown),4)

# ===============================
# 4ï¸âƒ£ å»ºç«‹ ETF DataFrame
# ===============================
@st.cache_data(ttl=CACHE_TTL)
def build_etf_dataframe(top_etfs):
    rows = []
    for code in top_etfs:
        price = fetch_price_history(code)
        vol, mdd = calculate_risk_metrics(price)
        rows.append({
            "ä»£ç¢¼": code,
            "å¹´åŒ–æ³¢å‹•åº¦": vol,
            "æœ€å¤§å›æ’¤": mdd
        })
    df = pd.DataFrame(rows)
    df.fillna(0, inplace=True)
    return df

# ===============================
# 5ï¸âƒ£ Î¸-model
# ===============================
def calculate_theta(age, horizon, loss_tol, market_react):
    theta = (
        -0.03 * (age - 40)
        + 0.04 * horizon
        + 0.05 * (loss_tol - 15)
        + {"ç«‹å³è³£å‡º": -1, "æŒæœ‰è§€æœ›": 0, "é€¢ä½åŠ ç¢¼": 1.2}[market_react]
    )
    return round(theta, 2)

# ===============================
# 6ï¸âƒ£ é¢¨éšªæŒ‡æ•¸
# ===============================
def compute_etf_risk_index(row):
    type_risk = 0.6  # å›ºå®šæ¬Šé‡
    score = 0.4 * type_risk + 0.3 * row["å¹´åŒ–æ³¢å‹•åº¦"] + 0.3 * row["æœ€å¤§å›æ’¤"]
    return round(score,3)

# ===============================
# 7ï¸âƒ£ Streamlit UI
# ===============================
st.set_page_config(page_title="å°ç£ ETF æ™ºæ…§æ’åº", layout="wide")
st.title("ğŸ“Š è‡ªå‹•æŠ“ç†±é–€ ETF Ã— é¢¨éšªæ’åºæ¨è–¦ç³»çµ±")

cols = st.columns(4)
age = cols[0].slider("ğŸ‘¤ å¹´é½¡", 20, 80, 35)
horizon = cols[1].slider("â³ æŠ•è³‡å¹´é™", 1, 40, 10)
loss_tol = cols[2].slider("ğŸ’¥ æœ€å¤§å¯æ¥å—æå¤± (%)", 0, 50, 15)
market_react = cols[3].radio("ğŸ“‰ å¸‚å ´ä¸‹è·Œ 20%", ["ç«‹å³è³£å‡º","æŒæœ‰è§€æœ›","é€¢ä½åŠ ç¢¼"])

# æŠ“ç†±é–€ ETF
if st.button("ğŸ“¡ æŠ“ç†±é–€ ETF"):
    top_etfs = fetch_top_etf_by_volume(ETF_CODES, top_n=10)
    if top_etfs:
        st.success(f"ğŸ“ˆ æˆäº¤é‡æ’è¡Œç†±é–€ ETFï¼ˆå‰ {len(top_etfs)}ï¼‰:")
        st.write(top_etfs)
    else:
        st.error("âŒ ç„¡æ³•å–å¾—ç†±é–€ ETFï¼Œè«‹ç¢ºèªç¶²è·¯æ­£å¸¸æˆ–ç¨å¾Œå†è©¦")

# è¨ˆç®—ä¸¦æ¨è–¦
if st.button("ğŸš€ è¨ˆç®—ä¸¦æ¨è–¦ ETF"):
    top_etfs = fetch_top_etf_by_volume(ETF_CODES, top_n=10)
    if not top_etfs:
        st.error("âŒ ç„¡æ³•å–å¾—ç†±é–€ ETFï¼Œè«‹ç¢ºèªç¶²è·¯æ­£å¸¸æˆ–ç¨å¾Œå†è©¦")
    else:
        etfs = build_etf_dataframe(top_etfs)
        if etfs.empty:
            st.warning("âš ï¸ ETF DataFrame ç‚ºç©ºï¼Œç„¡æ³•è¨ˆç®—")
        else:
            etfs["ETF é¢¨éšªæŒ‡æ•¸"] = etfs.apply(compute_etf_risk_index, axis=1)
            theta = calculate_theta(age, horizon, loss_tol, market_react)
            etfs["èˆ‡æŠ•è³‡äººè·é›¢"] = (etfs["ETF é¢¨éšªæŒ‡æ•¸"] - theta).abs()
            st.subheader(f"ğŸ“Š æŠ•è³‡äºº Î¸ å€¼ï¼š{theta}")
            st.dataframe(
                etfs.sort_values("èˆ‡æŠ•è³‡äººè·é›¢").head(TOP_N),
                use_container_width=True
            )

st.info("ğŸ“Œ è³‡æ–™ä¾†æºï¼šYahoo Financeï½œæ­·å²åƒ¹æ ¼åŠæˆäº¤é‡ï½œåƒ…ä¾›åƒè€ƒï¼ŒæŠ•è³‡éœ€è‡ªè² é¢¨éšª")
