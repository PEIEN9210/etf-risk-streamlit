# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
# -*- coding: utf-8 -*-

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import altair as alt

# ===============================
# åŸºæœ¬è¨­å®š
# ===============================
st.set_page_config(page_title="å°ç£ ETF å€‹äººåŒ–æ¨è–¦ç³»çµ±", layout="wide")
st.title("ğŸ“Š å°ç£ ETF å€‹äººåŒ–æ¨è–¦ï¼ˆSharpe + Beta + Î¸-modelï¼‰")

TRADING_DAYS = 252
RISK_FREE_RATE = 0.01  # 1%

# ===============================
# ETF Universeï¼ˆç©©å®šä¾†æºï¼‰
# ===============================
ETF_LIST = {
    "0050.TW": "è‚¡ç¥¨å‹",
    "006208.TW": "è‚¡ç¥¨å‹",
    "00692.TW": "è‚¡ç¥¨å‹",
    "00757.TW": "è‚¡ç¥¨å‹",
    "0056.TW": "é«˜è‚¡æ¯å‹",
    "00878.TW": "é«˜è‚¡æ¯å‹",
    "00919.TW": "é«˜è‚¡æ¯å‹",
}

MARKET_BENCHMARK = "0050.TW"

# ===============================
# æŠ“ ETF åƒ¹æ ¼è³‡æ–™
# ===============================
@st.cache_data(ttl=3600)
def fetch_price_data(code):
    df = yf.Ticker(code).history(period="1y")
    if df.empty or len(df) < 50:
        return None
    return df

# ===============================
# è¨ˆç®— Sharpe / Beta
# ===============================
def calc_metrics(df, market_df):
    returns = df["Close"].pct_change().dropna()
    market_returns = market_df["Close"].pct_change().dropna()

    common = returns.index.intersection(market_returns.index)
    returns = returns.loc[common]
    market_returns = market_returns.loc[common]

    ann_return = returns.mean() * TRADING_DAYS
    ann_vol = returns.std() * np.sqrt(TRADING_DAYS)

    sharpe = (ann_return - RISK_FREE_RATE) / ann_vol if ann_vol != 0 else 0

    beta = np.cov(returns, market_returns)[0, 1] / np.var(market_returns)

    return ann_return * 100, ann_vol * 100, sharpe, beta

# ===============================
# Î¸-modelï¼ˆæ¨™æº–åŒ–ï¼‰
# ===============================
def calc_theta(age, horizon, loss_tol, reaction):
    score = 0
    score += (80 - age) / 60          # å¹´è¼• â†’ é¢¨éšªé«˜
    score += horizon / 30
    score += loss_tol / 50
    score += {"è³£å‡º":0, "è§€æœ›":0.5, "åŠ ç¢¼":1}[reaction]

    return np.clip(score / 4, 0, 1)

# ===============================
# ä½¿ç”¨è€…è¼¸å…¥
# ===============================
st.sidebar.header("ğŸ‘¤ æŠ•è³‡äººé¢¨éšªè¨­å®š")

age = st.sidebar.slider("å¹´é½¡", 20, 80, 35)
horizon = st.sidebar.slider("æŠ•è³‡å¹´é™ï¼ˆå¹´ï¼‰", 1, 30, 10)
loss_tol = st.sidebar.slider("å¯æ¥å—æœ€å¤§æå¤± (%)", 0, 50, 20)
reaction = st.sidebar.radio("å¸‚å ´ä¸‹è·Œ 20% æ™‚", ["è³£å‡º","è§€æœ›","åŠ ç¢¼"])

theta = calc_theta(age, horizon, loss_tol, reaction)
st.sidebar.metric("Î¸ï¼ˆé¢¨éšªåå¥½æŒ‡æ•¸ï¼‰", round(theta, 2))

# ===============================
# ä¸»è³‡æ–™è¨ˆç®—
# ===============================
data = []

market_df = fetch_price_data(MARKET_BENCHMARK)

for etf, etf_type in ETF_LIST.items():
    df = fetch_price_data(etf)
    if df is None or market_df is None:
        continue

    ann_ret, ann_vol, sharpe, beta = calc_metrics(df, market_df)

    risk_profile = 0.6 * (ann_vol / 40) + 0.4 * (abs(beta - 1))
    risk_profile = np.clip(risk_profile, 0, 1)

    personal_score = sharpe - abs(theta - risk_profile)

    data.append({
        "ETF": etf,
        "é¡å‹": etf_type,
        "æœ€æ–°åƒ¹": round(df["Close"].iloc[-1], 2),
        "å¹´åŒ–å ±é…¬%": round(ann_ret, 2),
        "å¹´åŒ–æ³¢å‹•%": round(ann_vol, 2),
        "Sharpe": round(sharpe, 2),
        "Beta": round(beta, 2),
        "ETFé¢¨éšªè¼ªå»“": round(risk_profile, 2),
        "Î¸åé›¢": round(abs(theta - risk_profile), 2),
        "å€‹äººåŒ–åˆ†æ•¸": round(personal_score, 3)
    })

df_all = pd.DataFrame(data).sort_values("å€‹äººåŒ–åˆ†æ•¸", ascending=False)

# ===============================
# ç†±é–€ ETFï¼ˆä¸€å®šé¡¯ç¤ºï¼‰
# ===============================
st.subheader("ğŸ”¥ å¸‚å ´ç†±é–€ ETFï¼ˆSharpe æ’åºï¼‰")
st.dataframe(
    df_all.sort_values("Sharpe", ascending=False)
    [["ETF","é¡å‹","æœ€æ–°åƒ¹","Sharpe","Beta","å¹´åŒ–å ±é…¬%","å¹´åŒ–æ³¢å‹•%"]],
    use_container_width=True
)

# ===============================
# å€‹äººåŒ–æ¨è–¦
# ===============================
st.subheader("ğŸ¯ å€‹äººåŒ– ETF æ¨è–¦æ’åº")
st.dataframe(
    df_all[["ETF","é¡å‹","å€‹äººåŒ–åˆ†æ•¸","Sharpe","Beta","Î¸åé›¢"]],
    use_container_width=True
)

# ===============================
# æ°£æ³¡åœ–ï¼ˆSharpe Ã— Î¸ Ã— Betaï¼‰
# ===============================
st.subheader("ğŸ«§ ETF å€‹äººåŒ–è¦–è¦ºåŒ–")

bubble = alt.Chart(df_all).mark_circle(opacity=0.7).encode(
    x="Sharpe:Q",
    y="Î¸åé›¢:Q",
    size=alt.Size("Beta:Q", scale=alt.Scale(range=[100, 1500])),
    color="é¡å‹:N",
    tooltip=["ETF","Sharpe","Beta","Î¸åé›¢"]
)

st.altair_chart(bubble, use_container_width=True)

# ===============================
# é›·é”åœ–ï¼ˆçœŸæ­£ã€Œå€‹äººåŒ–ã€ï¼‰
# ===============================
st.subheader("ğŸ“¡ Top 3 ETF å€‹äººåŒ–é›·é”åœ–ï¼ˆé©é…åº¦ï¼‰")

top3 = df_all.head(3)

metrics = ["Sharpeé©é…", "å ±é…¬é©é…", "æ³¢å‹•é©é…", "Betaé©é…"]

radar = top3.melt(
    id_vars="ETF",
    value_vars=metrics,
    var_name="æŒ‡æ¨™",
    value_name="å€¼"
)

radar["order"] = radar["æŒ‡æ¨™"].map({m: i for i, m in enumerate(metrics)})
radar["è§’åº¦"] = radar["order"] * 2 * np.pi / len(metrics)

radar["x"] = radar["å€¼"] * np.cos(radar["è§’åº¦"])
radar["y"] = radar["å€¼"] * np.sin(radar["è§’åº¦"])

radar_closed = pd.concat(
    [radar, radar.groupby("ETF").apply(lambda d: d.iloc[[0]]).reset_index(drop=True)],
    ignore_index=True
)

area = alt.Chart(radar_closed).mark_area(opacity=0.3).encode(
    x=alt.X("x:Q", axis=None),
    y=alt.Y("y:Q", axis=None),
    color="ETF:N",
    detail="ETF:N",
    order="order:Q",
    tooltip=["ETF", "æŒ‡æ¨™", "å€¼"]
)

line = alt.Chart(radar_closed).mark_line().encode(
    x="x:Q",
    y="y:Q",
    color="ETF:N",
    detail="ETF:N",
    order="order:Q"
)

labels = pd.DataFrame({
    "æŒ‡æ¨™": metrics,
    "x": [1.2 * np.cos(i * 2 * np.pi / len(metrics)) for i in range(len(metrics))],
    "y": [1.2 * np.sin(i * 2 * np.pi / len(metrics)) for i in range(len(metrics))]
})

text = alt.Chart(labels).mark_text(fontSize=12).encode(
    x="x:Q",
    y="y:Q",
    text="æŒ‡æ¨™:N"
)

st.altair_chart(area + line + text, use_container_width=True)
