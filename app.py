# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf

# ===============================
# 0ï¸âƒ£ ç³»çµ±è¨­å®šï¼ˆé›†ä¸­ç®¡ç†ï¼‰
# ===============================
CACHE_TTL = 300
TOP_N = 5

# ===============================
# 1ï¸âƒ£ ETF éœæ…‹è³‡æ–™ï¼ˆSingle Sourceï¼‰
# ===============================
ETF_BASE_INFO = {
    '0050': ('å…ƒå¤§å°ç£50', 'è‚¡ç¥¨å‹', 3.3, '2025/07/15', 1.7, 18.2),
    '006208': ('å¯Œé‚¦å°50', 'è‚¡ç¥¨å‹', 3.5, '2025/07/20', 1.8, 17.8),
    '00713': ('å…ƒå¤§å°ç£é«˜æ¯ä½æ³¢', 'é«˜è‚¡æ¯å‹', 9.8, '2025/06/30', 5.28, 25.4),
    '00878': ('åœ‹æ³°æ°¸çºŒé«˜è‚¡æ¯', 'é«˜è‚¡æ¯å‹', 8.5, '2025/08/10', 2.01, 28.1),
    '0056': ('å…ƒå¤§é«˜è‚¡æ¯', 'é«˜è‚¡æ¯å‹', 7.2, '2025/08/01', 3.63, 19.6),
    '00692': ('å¯Œé‚¦å°ç£å…¬å¸æ²»ç†100', 'è‚¡ç¥¨å‹', 6.5, '2025/09/15', 1.5, 22.3),
    '00900': ('å¯Œé‚¦ç‰¹é¸é«˜è‚¡æ¯30', 'é«˜è‚¡æ¯å‹', 9.5, '2025/07/15', 1.21, 26.8),
    '00695B': ('å¯Œé‚¦ç¾å‚µ7-10å¹´', 'å‚µåˆ¸å‹', 3.2, '2025/12/15', 0.8, 4.2),
    '00794B': ('ç¾¤ç›Š7+ä¸­åœ‹æ”¿é‡‘å‚µ', 'å‚µåˆ¸å‹', 3.5, '2025/12/20', 0.9, 4.8),
    '00772B': ('ä¸­ä¿¡é«˜è©•ç´šå…¬å¸å‚µ', 'å‚µåˆ¸å‹', 4.0, '2025/11/01', 1.0, 5.1),
    '00757': ('çµ±ä¸€FANG+', 'è‚¡ç¥¨å‹', 0.5, '2025/03/01', 0.1, 45.0)
}

# ===============================
# 2ï¸âƒ£ å³æ™‚åƒ¹æ ¼ï¼ˆYahoo Financeï¼‰
# ===============================
@st.cache_data(ttl=CACHE_TTL)
def fetch_latest_price(code: str) -> float:
    try:
        data = yf.Ticker(f"{code}.TW").history(period="5d")
        return float(data['Close'].iloc[-1]) if not data.empty else np.nan
    except Exception:
        return np.nan

# ===============================
# 3ï¸âƒ£ ETF æ•´åˆè³‡æ–™è¡¨
# ===============================
@st.cache_data(ttl=CACHE_TTL)
def build_etf_dataframe() -> pd.DataFrame:
    rows = []

    for code, info in ETF_BASE_INFO.items():
        price = fetch_latest_price(code)
        name, etf_type, div_yield, ex_date, div_amt, total_ret = info

        rows.append({
            "ä»£ç¢¼": code,
            "åç¨±": name,
            "å‹æ…‹": etf_type,
            "å³æ™‚å ±åƒ¹": f"NT${price:.2f}" if not np.isnan(price) else "æš«ç„¡è³‡æ–™",
            "é…æ¯ç‡æ•¸å€¼": div_yield,
            "å¹´åŒ–é…æ¯ç‡": f"{div_yield}%",
            "æœ€æ–°é™¤æ¯æ—¥": ex_date,
            "æœ€æ–°é™¤æ¯é‡‘é¡": f"NT${div_amt}",
            "ç¸½å ±é…¬æ•¸å€¼": total_ret,
            "è¿‘ä¸€å¹´ç¸½å ±é…¬": f"{total_ret}%"
        })

    return pd.DataFrame(rows)

# ===============================
# 4ï¸âƒ£ è¡Œç‚ºé¢¨éšªæ¨¡å‹ï¼ˆÎ¸-modelï¼‰
# ===============================
def calculate_risk_score(age, horizon, loss_tol, volatility, expected_return, dividend_yield):
    theta = (
        -0.03 * (age - 40)
        + 0.04 * horizon
        + 0.05 * (loss_tol - 15)
        + {"ç«‹å³è³£å‡º": -1.0, "æŒæœ‰è§€æœ›": 0.0, "é€¢ä½åŠ ç¢¼": 1.2}.get(volatility, 0)
        + 0.03 * (expected_return - 6)
        - 0.04 * (dividend_yield - 3)
    )

    level = "ğŸŸ¢ä¿å®ˆå‹" if theta < -0.5 else "ğŸŸ¡å¹³è¡¡å‹" if theta < 0.8 else "ğŸ”´ç©æ¥µå‹"
    score = int(np.clip((theta + 2) * 2.5, 0, 10))

    return {"theta": round(theta, 2), "score": score, "level": level}

# ===============================
# 5ï¸âƒ£ ETF é¢¨éšªæŒ‡æ•¸
# ===============================
def compute_etf_risk_index(row):
    base = {"å‚µåˆ¸å‹": 0.2, "é«˜è‚¡æ¯å‹": 0.5, "è‚¡ç¥¨å‹": 0.8}.get(row["å‹æ…‹"], 0.9)
    return round(
        0.6 * base
        - 0.2 * (row["é…æ¯ç‡æ•¸å€¼"] / 10)
        + 0.2 * (row["ç¸½å ±é…¬æ•¸å€¼"] / 30),
        2
    )

# ===============================
# 6ï¸âƒ£ Streamlit UI
# ===============================
st.title("ğŸ† å°ç£ ETF å³æ™‚è³‡æ–™æ™ºæ…§è©•ä¼°ç³»çµ±")

if st.button("ğŸ“¡ é‡æ–°æŠ“å–è³‡æ–™"):
    st.cache_data.clear()
    st.rerun()

cols = st.columns([1,1,1,1,1,2])
age = cols[0].slider("ğŸ‘¤ å¹´é½¡", 20, 80, 35)
horizon = cols[1].slider("â³ æŠ•è³‡å¹´é™", 1, 40, 10)
loss_tol = cols[2].slider("ğŸ’¥ æœ€å¤§å¯æ¥å—æå¤± (%)", 0, 50, 15)
expected_return = cols[3].slider("ğŸ¯ é æœŸå ±é…¬ (%)", 2, 15, 6)
dividend_yield = cols[4].slider("ğŸ’° æœŸæœ›é…æ¯ (%)", 1, 8, 3)
volatility = cols[5].radio("ğŸ“‰ å¸‚å ´ä¸‹è·Œ 20%", ["ç«‹å³è³£å‡º","æŒæœ‰è§€æœ›","é€¢ä½åŠ ç¢¼"], horizontal=True)

if st.button("ğŸš€ ETF æ™ºæ…§é…å°"):
    st.session_state.result = calculate_risk_score(
        age, horizon, loss_tol, volatility, expected_return, dividend_yield
    )

if "result" in st.session_state:
    result = st.session_state.result
    st.subheader("ğŸ“Š æŠ•è³‡äººé¢¨éšªè¼ªå»“")
    c1, c2, c3 = st.columns(3)
    c1.metric("é¢¨éšªç­‰ç´š", result["level"])
    c2.metric("Î¸ å€¼", result["theta"])
    c3.metric("ç¸½åˆ†æ•¸", f'{result["score"]}/10')

    etfs = build_etf_dataframe()
    etfs["ETFé¢¨éšªæŒ‡æ•¸"] = etfs.apply(compute_etf_risk_index, axis=1)
    etfs["è·é›¢"] = (etfs["ETFé¢¨éšªæŒ‡æ•¸"] - result["theta"]).abs()

    st.subheader("ğŸ¯ Top ETF å»ºè­°")
    st.table(etfs.sort_values("è·é›¢").head(TOP_N)[
        ["ä»£ç¢¼","åç¨±","å‹æ…‹","å³æ™‚å ±åƒ¹","å¹´åŒ–é…æ¯ç‡","è¿‘ä¸€å¹´ç¸½å ±é…¬","ETFé¢¨éšªæŒ‡æ•¸"]
    ])

st.info("ğŸ“Œ è³‡æ–™ä¾†æºï¼šYahoo Financeï½œæ¯ 5 åˆ†é˜è‡ªå‹•æ›´æ–°")